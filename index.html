<html>
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Jogo de Damas - Clássico</title>
  <meta name="description" content="Jogue damas clássico com IA inteligente e múltiplos níveis de dificuldade. Perfeito para jogadores de todas as idades!">
  <meta name="keywords" content="damas, jogo, tabuleiro, estratégia, IA, inteligência artificial, clássico, tradicional, offline, PWA">
  <meta name="author" content="Lucio Carvalho">
  <meta name="theme-color" content="#8B2500" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Damas">
  <meta name="mobile-web-app-capable" content="yes">
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" href="icon.png.png">
  <link rel="apple-touch-icon" href="icon.png.png">
  <style>
    html, body {
      height: 100%;
      overflow: hidden; /* impede rolagem */
    }
    body { 
      /* Estilo do corpo da página */
      background-image: url('image/Dama11.jpg');
      font-family: Arial, sans-serif; 
      text-align: center; 
      background-color: #8B2500; 
      background-size: cover; 
      background-position: center;
      background-repeat: repeat;
      background-attachment: fixed;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      user-select: none;
      -webkit-user-select: none;
      overscroll-behavior: none;
    }
    button { 
      /* Estilo dos botões */
      background-color: #A0522D;
      border: 3px solid #696969;
      color: #080808;
      width: 150px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.4);
      font-weight: bold;
      cursor: pointer;
      transition: all 0.1s ease-in-out;
      min-height: 44px; /* Acessível para toque */
    }
    h2 {
      /* Estilo do título de login */
      color: #faf9f8;
      font-size: 30px;   
    }
    h3 {
      /* Estilo do indicador de turno - chip suave */
      background: rgba(255,255,255,0.12);
      width: fit-content;
      margin: 8px auto 14px;
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      box-shadow: 0 6px 16px rgba(0,0,0,0.25);
    }
    .game-header {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 15px;
      margin: 20px auto 0;
      max-width: 400px;
      padding: 0 20px;
    }
    .game-header h1 {
      margin: 0;
    }
    .game-header h1 button {
      width: 120px;
      font-size: 14px;
      border: 3px solid rgba(187, 4, 4, 0.85);
      border-radius: 10px;
    }
    .btn-sair {
      background-color: #A0522D;
      border: 3px solid rgba(187, 4, 4, 0.85);
      color: #080808;
      width: 120px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.4);
      font-weight: bold;
      cursor: pointer;
      transition: all 0.1s ease-in-out;
      min-height: 44px;
      font-size: 14px;
      border-radius: 10px;
    }
    #login-container {
      /* Estilo do contêiner de login */
      margin: 0;
      width: 100vw;
      height: 100vh;    
      box-sizing: border-box;
      border: 30px solid #8B2500;
      display: flex;
      align-items: stretch;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }
    #login-container::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(1200px 600px at 10% 10%, rgba(139,37,0,0.35), transparent 60%),
                  radial-gradient(1200px 600px at 90% 90%, rgba(0,0,0,0.35), transparent 60%),
                  linear-gradient(180deg, rgba(0,0,0,0.25), rgba(0,0,0,0.55));
      pointer-events: none;
    }
    .login-grid {
      position: relative;
      display: grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 28px;
      align-items: center;
      width: min(1100px, 92vw);
      margin: auto;
      padding: 24px 10px;
      z-index: 1;
    }
    .hero {
      text-align: left;
      color: #fff;
      padding: 8px 6px;
    }
    .hero h1 {
      margin: 0 0 8px 0;
      font-size: clamp(26px, 4.5vw, 44px);
      line-height: 1.08;
      letter-spacing: 0.2px;
      text-shadow: 0 4px 16px rgba(0,0,0,0.35);
    }
    .hero p {
      margin: 0 0 14px 0;
      font-size: clamp(14px, 2.2vw, 18px);
      color: #f3ece6;
      opacity: .95;
    }
    .hero ul { list-style: none; padding: 0; margin: 14px 0 18px; }
    .hero li { margin: 8px 0; display: flex; align-items: center; gap: 8px; color: #f7f4f1; opacity: .95; }
    .hero li::before { content: "✔"; color: #ffd27a; font-weight: bold; }
    .hero .cta {
      display: inline-block;
      background: #8B2500;
      color: #fff;
      border: 0;
      padding: 12px 18px;
      border-radius: 12px;
      box-shadow: 0 10px 18px rgba(0,0,0,0.25);
      cursor: pointer;
      transition: transform .08s ease, filter .2s ease;
      min-height: 44px;
    }
    .hero .cta:hover { filter: brightness(1.06); }
    .hero .cta:active { transform: translateY(1px); }
    .content {
      /* Card de login (glass) */
      position: relative;
      top: auto;
      left: auto;
      transform: none;  
      width: min(92vw, 420px);
      padding: 24px 22px;
      border-radius: 16px;
      background: rgba(255,255,255,0.08);
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.18);
    }
    .content input {
      /* Estilo dos campos de entrada */
      background-color: rgba(231, 203, 169, 0.9);
      display: block;
      margin: 10px auto;
      padding: 12px 14px;
      width: 100%;
      max-width: none;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,0.15);
      outline: none;
    }
    .content button {
      /* Estilo dos botões no contêiner de login */
      background-color: #8B2500;
      border: 0;
      margin: 8px 0 0 0;
      padding: 12px 14px;
      color: #f8f5f5; 
      width: 100%;
      box-shadow: 0 6px 12px rgba(0,0,0,0.25);
      font-weight: bold;
      cursor: pointer;
      transition: transform .06s ease, box-shadow .2s ease, background .2s ease;
      border-radius: 10px;
    }
    .content button:hover { filter: brightness(1.05); }
    .content button:active { transform: translateY(1px); }
    .content label {
      /* Estilo dos rótulos no login */
      color: #faf9f8;
      font-size: 16px;
      margin: 10px auto 4px;
      text-align: left;
      width: 100%;
    }
    .content .subtitle { color: #f0e9e3; opacity: .9; margin-top: -6px; margin-bottom: 14px; }
    #turno { 
      /* Estilo do texto de turno */
      font-size: 24px; 
      font-weight: bold; 
    }
    .controls, .login { 
      /* Margem para controles e login */
      margin: 20px; 
    }
    #jogo-container {
      /* Estilo do contêiner do jogo */
      margin: auto;
      width: 100vw;
      height: 100vh;
      padding: auto;
      width: fit-content;
    }
    .controls {
      /* Estilo do painel de controles - versão suave */
      background: rgba(255,255,255,0.08);
      text-align: center;
      align-items: center;
      padding: 16px 18px;
      width: fit-content;
      margin: 16px auto 40px; /* separa do tabuleiro */
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    .controls label { 
      /* Estilo dos rótulos nos controles */
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      color: #f7f4f1;
      margin: 6px 4px;
      align-items: center;
    }
    .controls button { 
      /* Estilo dos botões nos controles */
      background: linear-gradient(180deg, #b13910, #b13910);
      border: 0;
      color: #fff;
      margin: 12px 6px 0 6px;
      width: 140px;
      padding: 10px 12px;
      box-shadow: 0 6px 14px rgba(0,0,0,0.25);
      font-weight: 700;
      cursor: pointer;
      transition: transform .08s ease, filter .2s ease;
      border-radius: 10px;
    }
    .controls button:hover { filter: brightness(1.06); }
    .controls button:active { transform: translateY(1px); }
    button:active {
      /* Efeito ao clicar nos botões */
      box-shadow: inset 2px 2px 5px rgba(0,0,0,0.3);
      transform: translateY(2px);
    }
    .controls select { 
      /* Estilo dos seletores nos controles */
      background: rgba(160, 82, 45, 0.85);
      border: 1px solid rgba(255,255,255,0.25);
      color: #fff;
      margin: 2px;
      padding: 6px 10px;
      border-radius: 10px;
      outline: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2) inset;
    }
    /* Modal personalizado */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    .modal {
      background: rgba(255,255,255,0.08);
      color: #f7f4f1;
      padding: 16px 18px;
      border-radius: 14px;
      min-width: 280px;
      max-width: 90vw;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.2);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      text-align: center;
    }
    .modal h4 { margin: 0 0 10px; color: #f7f4f1; }
    .modal p { margin: 8px 0 14px; color: #f7f4f1; }
    .modal-buttons { display: flex; gap: 12px; justify-content: center; }
    .modal-buttons button {
      background-color: #A0522D;
      border: 3px solid rgba(187, 4, 4, 0.85);
      color: #080808;
      width: 140px;
      padding: 10px 12px;
      box-shadow: 0 6px 14px rgba(0,0,0,0.25);
      font-weight: 700;
      cursor: pointer;
      transition: transform .08s ease, filter .2s ease;
      border-radius: 10px;
    }
    .tabuleiro { 
      /* Estilo do tabuleiro */
      display: grid; 
      grid-template-columns: repeat(8, 60px); 
      margin: 20px auto 20px; 
      width: 480px; 
      border: 8px solid rgba(187, 4, 4, 0.85);
      border-radius: 14px;
      box-shadow: 0 18px 40px rgba(0,0,0,0.45);
      overflow: hidden;
      touch-action: manipulation;
      backdrop-filter: blur(2px);
    }
    .Anuncios {
      margin: 10px auto;
      width: 320px;
      min-height: 100px;
      border-radius: 14px;
      box-shadow: 0 18px 40px rgba(0,0,0,0.45);
      background-color: #f0f0f0;
      border: 2px solid #ccc;
      display: block;
    }
    .peca.animando {
      position: absolute;
      z-index: 10;
      transition: transform 0.4s cubic-bezier(.4,2,.6,1);
      pointer-events: none;
    }
    .casa {
      /* Estilo das casas do tabuleiro */
      width: 60px;
      height: 60px;
      display: flex;
      justify-content: center;
      align-items: center;
      
    }
    .clara { background-color: #eee; }
    .escura { background-color: #444; }
    .peca {
      /* Estilo das peças */
      border-radius: 50%;
      width: 40px;
      height: 40px;
      box-shadow: inset 0 6px 10px rgba(0,0,0,0.25), 0 4px 10px rgba(0,0,0,0.25);
    }
    .dama::after {
      /* Estilo do símbolo de dama */
      content: "👑";
      position: absolute;
      font-size: 20px;
      color: yellow;
    }
    .selecionada { outline: 3px solid yellow; } /* Casa selecionada */
    .possivel { background-color: green !important; } /* Casa de movimento possível */
    #jogo-container { display: block; } /* tela principal */
    .nivel-bloqueado { 
      /* Estilo de níveis bloqueados */
      background-color: #A0522D;
      cursor: not-allowed; 
    }
    /* Botão de instalar PWA */
    #btn-instalar {
      position: fixed;
      right: calc(env(safe-area-inset-right) + 12px);
      bottom: calc(env(safe-area-inset-bottom) + 12px);
      z-index: 1000;
      display: none;
    }
/* ================== MEDIA QUERIES ================== */

  @media screen and (max-width: 768px) {
    body {
      background-image: url('image/Dama11.png') !important;
      background-attachment: scroll;
      background-size: cover;
      background-position: center;
      background-repeat: repeat;
    }
    #login-container { 
      width: 100vw; 
      height: 100vh; 
      border-width: 2vw; 
      border-radius: 10px; 
    }
    .login-grid {
      grid-template-columns: 1fr;
      gap: 20px;
      width: 95vw;
      padding: 20px 10px;
    }
    .hero {
      text-align: center;
      order: 2;
    }
    .content {
      order: 1;
      width: 100%;
      padding: 20px 16px;
    }
    h2 { 
      font-size: 1.5rem; 
    }
    h3 { 
      font-size: 1rem; 
      width: 70%; 
    }
    .content input, .content button {
      width: 100%;
      max-width: none;
      margin: 8px auto;
      display: block;
    }
    .tabuleiro {
      grid-template-columns: repeat(8, 11fr);
      width: 96vw;
      min-width: 0;
    }
    .Anuncios {
      width: 90vw;
      max-width: 400px;
    }
    .casa {
      width: 12vw;
      height: 12vw;
      min-width: 30px;
      min-height: 30px;
    }
    .peca {
      width: 70%;
      height: 70%;
      min-width: 20px;
      min-height: 20px;
    }
  }

  /* Layout somente vertical: removido estilo específico para horizontal */

  </style>
  
  <!-- Google AdMob -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9090639456230110"
     crossorigin="anonymous"></script>
</head>
<body>
  <!-- Áudios -->
  <audio id="som-captura" src="audio/captura.mp3"></audio>
  <audio id="som-distribuicao" src="audio/distribuicao.mp3"></audio>
  <audio id="som-movimento" src="audio/movimento.mp3"></audio>
  <audio id="som-vitoria" src="audio/vitoria.mp3"></audio>
  <audio id="som-click" src="audio/click.mp3"></audio>
  <audio id="musica-fundo" src="audio/drama.mp3" loop></audio>


  

  <!-- Contêiner do jogo -->
  <div id="jogo-container">
    <div class="game-header">
      <h1><button onclick="alternarMenu()">Opções de Jogo</button></h1>
      <button class="btn-sair" onclick="sairDoAplicativo()">Sair</button>
    </div>
    <div class="controls" id="menu">
      <label>Jogador 1:
        <select id="corJ1">
          <option>Jatobá</option>
          <option>Castanho</option>
          <option>Verde</option>
          <option>Vermelho</option>
          <option>Preta</option>
          <option>Imbuia</option>
        </select>
      </label>
      <label>Jogador 2:
        <select id="corJ2">
          <option>Castanho</option>
          <option>Jatobá</option>
          <option>Verde</option>
          <option>Vermelho</option>
          <option>Preta</option>
          <option>Imbuia</option>
        </select>
      </label>
      <label>Tabuleiro:
        <select id="temaTabuleiro">
          <option>Preto-Castanho</option>
          <option>Preto-Branco</option>
          <option>Teca-Nogueira</option>
          <option>Preto-Teca</option>
          <option>Teca-Carvalho</option>
        </select>
      </label>
      <label>Adversário:
        <select id="modoJogo">
          <option>Jogador Local</option>
          <option>Contra a Máquina</option>
        </select>
      </label>
      <label>Dificuldade:
        <select id="nivelDificuldade">
          <option value="1">Nível 1</option>
          <option value="2">Nível 2</option>
          <option value="3">Nível 3</option>
          <option value="4">Nível 4</option>
          <option value="5">Nível 5</option>
          <option value="6">Nível 6</option>
          <option value="7">Nível 7</option>
          <option value="8">Nível 8</option>
          <option value="9">Nível 9</option>
          <option value="10">Nível 10</option>
        </select>
      </label>
      
      <div style="margin-top:12px;text-align:left">
        <h3 style="margin:8px 0 6px">Volume</h3>
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px">
          <button id="btn-vol-menor" style="width:40px">-</button>
          <span id="label-volume">100%</span>
          <button id="btn-vol-maior" style="width:40px">+</button>
        </div>
        <label style="grid-template-columns:auto 1fr;align-items:center;gap:8px">
          <input type="checkbox" id="mute-musica" /> Silenciar música de fundo
        </label>
        <label style="grid-template-columns:auto 1fr;align-items:center;gap:8px">
          <input type="checkbox" id="mute-efeitos" /> Silenciar sons de movimentos
        </label>
      </div>
      <div style="margin-top:12px;text-align:left">
        <h3 style="margin:8px 0 6px">Prévia</h3>
        <div id="preview" style="display:grid;grid-template-columns:repeat(8,14px);gap:0;border:2px solid rgba(187,4,4,0.85);border-radius:6px;width:112px;overflow:hidden"></div>
      </div>
      <div style="display:flex;justify-content:center;gap:12px;margin-top:12px">
        <button onclick="iniciarJogo()">Iniciar Jogo</button>
        <button id="btn-voltar-jogo" onclick="voltarAoJogo()">Voltar ao Jogo</button>
      </div>
    </div>
    <div id="tabuleiro" class="tabuleiro"></div>
    <h3 id="turno"></h3>
    <div id="Anuncios" class="Anuncios" style="display: none;">
      <!-- Anúncio Banner do Google AdMob -->
      <ins class="adsbygoogle"
           style="display:block"
           data-ad-client="ca-pub-9090639456230110"
           data-ad-slot="6220961510"
           data-ad-format="auto"
           data-full-width-responsive="true"></ins>
    </div>
    
    <!-- Anúncio Intersticial (Transição) - Oculto por padrão -->
    <div id="anuncioIntersticial" style="display: none;">
      <ins class="adsbygoogle"
           data-ad-client="ca-pub-9090639456230110"
           data-ad-slot="5888453862"
           data-ad-format="interstitial"></ins>
    </div>    
  </div>
  <div id="modal-overlay" class="modal-overlay">
    <div class="modal">
      <h4 id="modal-title">Resultado</h4>
      <p id="modal-message"></p>
      <div class="modal-buttons" id="modal-buttons"></div>
    </div>
  </div>
  <div id="confete-container" style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:999;display:none;"></div>
  <button id="btn-instalar">Instalar App</button>

  <script>

    // === Funções de Utilidade ===
    window.onload = function() {
      document.querySelectorAll("button").forEach(btn => {
        btn.addEventListener("click", () => tocarSom("som-click"));
      });
      // PWA: registro do service worker
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('sw.js').catch(() => {});
      }
      inicializarPWA();
      
      // Inicializa anúncios do Google AdMob
      try {
        (adsbygoogle = window.adsbygoogle || []).push({});
      } catch (e) {
        console.error('Erro ao carregar anúncio:', e);
      }
      
      // Inicializa anúncio intersticial
      try {
        (adsbygoogle = window.adsbygoogle || []).push({});
      } catch (e) {
        console.error('Erro ao carregar anúncio intersticial:', e);
      }
    };
    // === PWA Instalação ===
    let eventoInstalacaoDeferido = null;
    function inicializarPWA() {
      window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault();
        eventoInstalacaoDeferido = e;
        const btn = document.getElementById('btn-instalar');
        btn.style.display = 'block';
        btn.onclick = async () => {
          btn.disabled = true;
          try {
            if (eventoInstalacaoDeferido) {
              eventoInstalacaoDeferido.prompt();
              const { outcome } = await eventoInstalacaoDeferido.userChoice;
              if (outcome === 'accepted') btn.style.display = 'none';
              eventoInstalacaoDeferido = null;
            }
          } finally {
            btn.disabled = false;
          }
        };
      });
      window.addEventListener('appinstalled', () => {
        const btn = document.getElementById('btn-instalar');
        btn.style.display = 'none';
      });
    }

    // === Variáveis globais ===
    let tabuleiro = [];
    let turnoJogador = 1;
    let pecaSelecionada = null;
    let cores = { "Imbuia": "#7F5A36", "Preta": "#000", "Jatobá": "#8B4000", "Castanho": "#6F4E37", "Verde": "green", "Vermelho": "red" };
    let temaCores = { "Preto-Branco": ["#000", "#fff"], "Preto-Castanho": ["#000", "#A47149"], "Teca-Nogueira": ["#8B2500", "#B98E68"], "Preto-Teca": ["#000", "#8B2500"], "Teca-Carvalho": ["#8B2500", "#D6A77A"] };
    let corPecas = {};
    let corCasas = [];
    let capturaObrigatoria = false;
    let modo = "";
    let nivel = 1;
    let turnoDaIA = false;
    // Persistência global (sem usuário)
    function atualizarNiveisDesbloqueados() {
      let nivelDesbloqueado = 1;
      try {
        nivelDesbloqueado = parseInt(localStorage.getItem('nivel_desbloqueado') || '1');
      } catch (e) {}
      const selectNivel = document.getElementById('nivelDificuldade');
      for (let i = 0; i < selectNivel.options.length; i++) {
        const nivelOpcao = parseInt(selectNivel.options[i].value);
        if (nivelOpcao > nivelDesbloqueado) {
          selectNivel.options[i].disabled = true;
          selectNivel.options[i].classList.add('nivel-bloqueado');
        } else {
          selectNivel.options[i].disabled = false;
          selectNivel.options[i].classList.remove('nivel-bloqueado');
        }
      }
    }
    function desbloquearProximoNivel() {
      const nivelAtual = parseInt(document.getElementById('nivelDificuldade').value);
      const proximoNivel = Math.min(10, nivelAtual + 1);
      try {
        const atual = parseInt(localStorage.getItem('nivel_desbloqueado') || '1');
        if (proximoNivel > atual) {
          localStorage.setItem('nivel_desbloqueado', String(proximoNivel));
          atualizarNiveisDesbloqueados();
        }
      } catch (e) {}
    }


    // === Lógica do Jogo ===

    // Verifica se uma posição está dentro dos limites do tabuleiro (8x8)
    function estaDentroDosLimites(i, j) {
      return i >= 0 && i < 8 && j >= 0 && j < 8;
    }

    // Obtém movimentos regulares (não-capturas) possíveis para uma peça
    function obterMovimentosRegularesPossiveis(i, j) {
      let peca = tabuleiro[i][j];
      let movimentos = [];
      // Define direções com base no jogador: Jogador 1 (para cima), Jogador 2 (para baixo), damas (todas direções)
      let direcoes = peca.dama ? [[-1,-1], [-1,1], [1,-1], [1,1]] : 
        (peca.jogador === 1 ? [[-1,-1], [-1,1]] : [[1,-1], [1,1]]);
      
      for (let dir of direcoes) {
        let di = dir[0], dj = dir[1];
        let ni = i + di, nj = j + dj;
        if (peca.dama) {
          // Damas podem se mover várias casas na mesma direção
          while (estaDentroDosLimites(ni, nj) && !tabuleiro[ni][nj]) {
            movimentos.push({i: ni, j: nj});
            ni += di;
            nj += dj;
          }
        } else if (estaDentroDosLimites(ni, nj) && !tabuleiro[ni][nj]) {
          // Peças regulares movem-se apenas uma casa
          movimentos.push({i: ni, j: nj});
        }
      }
      return movimentos;
    }

    // Obtém capturas possíveis para uma peça, permitindo capturas em qualquer direção diagonal
    // Parâmetros opcionais i0, j0: posição anterior (para evitar voltar na mesma direção em capturas múltiplas)
    function obterCapturasPossiveis(i, j, i0 = null, j0 = null) {
      let peca = tabuleiro[i][j];
      let capturas = [];
      // Peças regulares e damas podem capturar em todas as direções diagonais
      let direcoes = [[-1,-1], [-1,1], [1,-1], [1,1]];

      // Se há posição anterior, calcula a direção de onde veio para bloqueá-la
      let direcaoBloqueada = null;
      if (i0 !== null && j0 !== null) {
        let deltaI = i - i0;
        let deltaJ = j - j0;
        // Normaliza a direção (apenas o sinal importa)
        if (deltaI !== 0 && deltaJ !== 0) {
          let dirI = deltaI > 0 ? 1 : -1;
          let dirJ = deltaJ > 0 ? 1 : -1;
          // A direção bloqueada é a oposta (de onde veio)
          direcaoBloqueada = [-dirI, -dirJ];
        }
      }

      for (let dir of direcoes) {
        let di = dir[0], dj = dir[1];
        
        // Bloqueia a direção oposta em capturas múltiplas
        if (direcaoBloqueada && di === direcaoBloqueada[0] && dj === direcaoBloqueada[1]) {
          continue; // Pula esta direção
        }
        
        let ni = i + di, nj = j + dj;
        if (peca.dama) {
          // Damas podem capturar em várias casas na mesma direção
          while (estaDentroDosLimites(ni, nj)) {
            if (tabuleiro[ni][nj] && tabuleiro[ni][nj].jogador !== peca.jogador) {
              let mi = ni + di, mj = nj + dj;
              // Adiciona todas as casas vazias após a peça capturada
              while (estaDentroDosLimites(mi, mj) && !tabuleiro[mi][mj]) {
                capturas.push({i: mi, j: mj, capturadaI: ni, capturadaJ: nj});
                mi += di;
                mj += dj;
              }
              break;
            }
            if (tabuleiro[ni][nj]) break;
            ni += di;
            nj += dj;
          }
        } else {
          // Peças regulares capturam pulando uma casa com peça inimiga para uma casa vazia
          let mi = i + 2 * di, mj = j + 2 * dj;
          if (estaDentroDosLimites(ni, nj) && estaDentroDosLimites(mi, mj) &&
              tabuleiro[ni][nj] && tabuleiro[ni][nj].jogador !== peca.jogador && !tabuleiro[mi][mj]) {
            capturas.push({i: mi, j: mj, capturadaI: ni, capturadaJ: nj});
          }
        }
      }
      return capturas;
    }

    // Verifica se há capturas possíveis para um jogador
    function temCapturasPossiveis(jogador) {
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (tabuleiro[i][j] && tabuleiro[i][j].jogador === jogador) {
            let capturas = obterCapturasPossiveis(i, j);
            if (capturas.length > 0) return true;
          }
        }
      }
      return false;
    }

    // Obtém todos os movimentos possíveis para um jogador, priorizando capturas
    function obterTodosMovimentosPossiveis(jogador) {
      let movimentosPossiveis = [];
      let existemCapturas = temCapturasPossiveis(jogador);
      
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (tabuleiro[i][j] && tabuleiro[i][j].jogador === jogador) {
            let capturas = obterCapturasPossiveis(i, j);
            let movimentos;
            
            // Se existem capturas obrigatórias, apenas peças com captura podem se mover
            if (existemCapturas) {
              movimentos = capturas; // Apenas capturas, se houver
            } else {
              movimentos = capturas.concat(obterMovimentosRegularesPossiveis(i, j));
            }
            
            movimentos.forEach(mov => {
              movimentosPossiveis.push({ de: {i, j}, para: mov });
            });
          }
        }
      }
      return movimentosPossiveis;
    }

    // Obtém movimentos possíveis para uma peça específica, priorizando capturas
    // Parâmetros opcionais i0, j0: posição anterior (para capturas múltiplas)
    function obterTodosMovimentos(i, j, i0 = null, j0 = null) {
      let capturas = obterCapturasPossiveis(i, j, i0, j0);
      
      // Se está em captura múltipla (i0 e j0 não null), retorna APENAS as capturas da peça atual
      // Não verifica o tabuleiro inteiro, pois a mesma peça DEVE continuar capturando
      if (i0 !== null && j0 !== null) {
        return capturas; // Capturas obrigatórias da mesma peça
      }
      
      // Se não está em captura múltipla, verifica se o jogador tem capturas disponíveis
      if (temCapturasPossiveis(tabuleiro[i][j].jogador)) {
        // Apenas retorna capturas. Se esta peça não tem captura, retorna array vazio
        return capturas;
      }
      
      // Se não há capturas obrigatórias, permite movimentos regulares
      return capturas.concat(obterMovimentosRegularesPossiveis(i, j));
    }

    // Avalia o estado do tabuleiro para a IA, atribuindo pontuações
    function avaliarTabuleiro(tabuleiroParam, jogador) {
      let pontuacao = 0;
      let oponente = jogador === 1 ? 2 : 1;
      let pecasJogador = 0, pecasOponente = 0;
      let damasJogador = 0, damasOponente = 0;
      let centroJogador = 0;

      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (tabuleiroParam[i][j]) {
            if (tabuleiroParam[i][j].jogador === jogador) {
              pecasJogador++;
              if (tabuleiroParam[i][j].dama) damasJogador++;
              if (i >= 2 && i <= 5 && j >= 2 && j <= 5) centroJogador++;
            } else {
              pecasOponente++;
              if (tabuleiroParam[i][j].dama) damasOponente++;
            }
          }
        }
      }

      pontuacao += pecasJogador * 10;
      pontuacao -= pecasOponente * 10;
      pontuacao += damasJogador * 50;
      pontuacao -= damasOponente * 50;
      pontuacao += centroJogador * 5;
      return pontuacao;
    }

    // Aplica um movimento no tabuleiro para simulação da IA
    function aplicarMovimento(tabuleiroParam, movimento) {
      let novoTabuleiro = tabuleiroParam.map(row => row.map(cell => cell ? { ...cell } : null));
      let { de, para } = movimento;
      novoTabuleiro[para.i][para.j] = novoTabuleiro[de.i][de.j];
      novoTabuleiro[de.i][de.j] = null;
      if (para.capturadaI !== undefined && para.capturadaJ !== undefined) {
        novoTabuleiro[para.capturadaI][para.capturadaJ] = null;
      }
      // Coroação só ocorre se não houver capturas adicionais na posição final
      if (!obterCapturasPossiveisSim(novoTabuleiro, para.i, para.j).length && 
          ((novoTabuleiro[para.i][para.j].jogador === 1 && para.i === 0) ||
           (novoTabuleiro[para.i][para.j].jogador === 2 && para.i === 7))) {
        novoTabuleiro[para.i][para.j].dama = true;
      }
      return novoTabuleiro;
    }

    // Versões "simuladas" que operam sobre um tabuleiro fornecido
    function obterCapturasPossiveisSim(tabuleiroParam, i, j) {
      let peca = tabuleiroParam[i][j];
      if (!peca) return [];
      let capturas = [];
      let direcoes = [[-1,-1], [-1,1], [1,-1], [1,1]];
      for (let dir of direcoes) {
        let di = dir[0], dj = dir[1];
        let ni = i + di, nj = j + dj;
        if (peca.dama) {
          while (estaDentroDosLimites(ni, nj)) {
            if (tabuleiroParam[ni][nj] && tabuleiroParam[ni][nj].jogador !== peca.jogador) {
              let mi = ni + di, mj = nj + dj;
              while (estaDentroDosLimites(mi, mj) && !tabuleiroParam[mi][mj]) {
                capturas.push({i: mi, j: mj, capturadaI: ni, capturadaJ: nj});
                mi += di; mj += dj;
              }
              break;
            }
            if (tabuleiroParam[ni][nj]) break;
            ni += di; nj += dj;
          }
        } else {
          let mi = i + 2 * di, mj = j + 2 * dj;
          if (estaDentroDosLimites(ni, nj) && estaDentroDosLimites(mi, mj) &&
              tabuleiroParam[ni][nj] && tabuleiroParam[ni][nj].jogador !== peca.jogador && !tabuleiroParam[mi][mj]) {
            capturas.push({i: mi, j: mj, capturadaI: ni, capturadaJ: nj});
          }
        }
      }
      return capturas;
    }

    function obterMovimentosRegularesPossiveisSim(tabuleiroParam, i, j) {
      let peca = tabuleiroParam[i][j];
      if (!peca) return [];
      let movimentos = [];
      let direcoes = peca.dama ? [[-1,-1], [-1,1], [1,-1], [1,1]] : 
        (peca.jogador === 1 ? [[-1,-1], [-1,1]] : [[1,-1], [1,1]]);
      for (let dir of direcoes) {
        let di = dir[0], dj = dir[1];
        let ni = i + di, nj = j + dj;
        if (peca.dama) {
          while (estaDentroDosLimites(ni, nj) && !tabuleiroParam[ni][nj]) {
            movimentos.push({i: ni, j: nj});
            ni += di; nj += dj;
          }
        } else if (estaDentroDosLimites(ni, nj) && !tabuleiroParam[ni][nj]) {
          movimentos.push({i: ni, j: nj});
        }
      }
      return movimentos;
    }

    function temCapturasPossiveisSim(tabuleiroParam, jogador) {
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (tabuleiroParam[i][j] && tabuleiroParam[i][j].jogador === jogador) {
            let capturas = obterCapturasPossiveisSim(tabuleiroParam, i, j);
            if (capturas.length > 0) return true;
          }
        }
      }
      return false;
    }

    function obterTodosMovimentosPossiveisSim(tabuleiroParam, jogador) {
      let movimentosPossiveis = [];
      let capturasObrigatorias = temCapturasPossiveisSim(tabuleiroParam, jogador);
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (tabuleiroParam[i][j] && tabuleiroParam[i][j].jogador === jogador) {
            let capturas = obterCapturasPossiveisSim(tabuleiroParam, i, j);
            let movimentos = capturasObrigatorias ? capturas : capturas.concat(obterMovimentosRegularesPossiveisSim(tabuleiroParam, i, j));
            movimentos.forEach(mov => movimentosPossiveis.push({ de: {i, j}, para: mov }));
          }
        }
      }
      return movimentosPossiveis;
    }

    // Algoritmo Minimax para níveis avançados da IA
    function minimax(tabuleiroParam, profundidade, jogador, alpha, beta) {
      if (profundidade === 0) {
        return { pontuacao: avaliarTabuleiro(tabuleiroParam, 2), movimento: null };
      }
      let movimentos = obterTodosMovimentosPossiveisSim(tabuleiroParam, jogador);
      if (movimentos.length === 0) {
        return { pontuacao: jogador === 2 ? -Infinity : Infinity, movimento: null };
      }
      let melhorMovimento = null;
      if (jogador === 2) {
        let melhorPontuacao = -Infinity;
        for (let movimento of movimentos) {
          let novoTabuleiro = aplicarMovimento(tabuleiroParam, movimento);
          let resultado = minimax(novoTabuleiro, profundidade - 1, jogador === 1 ? 2 : 1, alpha, beta);
          if (resultado.pontuacao > melhorPontuacao) {
            melhorPontuacao = resultado.pontuacao;
            melhorMovimento = movimento;
          }
          alpha = Math.max(alpha, melhorPontuacao);
          if (beta <= alpha) break;
        }
        return { pontuacao: melhorPontuacao, movimento: melhorMovimento };
      } else {
        let melhorPontuacao = Infinity;
        for (let movimento of movimentos) {
          let novoTabuleiro = aplicarMovimento(tabuleiroParam, movimento);
          let resultado = minimax(novoTabuleiro, profundidade - 1, jogador === 1 ? 2 : 1, alpha, beta);
          if (resultado.pontuacao < melhorPontuacao) {
            melhorPontuacao = resultado.pontuacao;
            melhorMovimento = movimento;
          }
          beta = Math.min(beta, melhorPontuacao);
          if (beta <= alpha) break;
        }
        return { pontuacao: melhorPontuacao, movimento: melhorMovimento };
      }
    }

    // Executa a jogada da IA com base no nível de dificuldade
    function jogadaDaIA() {
      if (modo !== "Contra a Máquina" || turnoJogador !== 2 || turnoDaIA) return;
      turnoDaIA = true;
      document.getElementById("tabuleiro").style.pointerEvents = "none";
      setTimeout(() => {
        let movimentos;
        if (pecaSelecionada) {
          // Considera apenas movimentos da peça selecionada, priorizando capturas
          movimentos = obterTodosMovimentos(pecaSelecionada.i, pecaSelecionada.j).map(mov => ({ de: pecaSelecionada, para: mov }));
        } else {
          // Obtém todos os movimentos possíveis para o Jogador 2
          movimentos = obterTodosMovimentosPossiveis(2);
        }
        if (!movimentos || movimentos.length === 0) {
          turnoDaIA = false;
          document.getElementById("tabuleiro").style.pointerEvents = "auto";
          verificarVitoria();
          return;
        }
        let movimentoEscolhido;
        if (nivel <= 3) {
          // Níveis baixos: escolha aleatória, priorizando capturas
          let capturas = movimentos.filter(m => m.para.capturadaI !== undefined);
          if (capturas.length > 0) {
            movimentoEscolhido = capturas[Math.floor(Math.random() * capturas.length)];
          } else {
            movimentoEscolhido = movimentos[Math.floor(Math.random() * movimentos.length)];
          }
        } else if (nivel <= 6) {
          // Níveis médios: escolhe com base em pontuação simples
          movimentoEscolhido = movimentos.reduce((melhor, mov) => {
            let pontuacao = 0;
            if (mov.para.capturadaI !== undefined) pontuacao += nivel === 6 ? 100 : 50;
            // Bônus por coroação iminente (jogador 2 chegando à última linha)
            if (mov.de && typeof mov.de.i === 'number' && mov.para && typeof mov.para.i === 'number') {
              const pecaOrigem = tabuleiro[mov.de.i][mov.de.j];
              if (pecaOrigem && !pecaOrigem.dama && pecaOrigem.jogador === 2 && mov.para.i === 7) {
                pontuacao += 30;
              }
            }
            if (nivel >= 5) {
              let novoTabuleiro = aplicarMovimento(tabuleiro, mov);
              let capturasOponente = obterTodosMovimentosPossiveisSim(novoTabuleiro, 1).filter(m => m.para.capturadaI !== undefined);
              pontuacao -= capturasOponente.length * 10;
            }
            return !melhor || pontuacao > melhor.pontuacao ? { movimento: mov, pontuacao } : melhor;
          }, null)?.movimento;
        } else {
          // Níveis altos: usa Minimax com profundidade variável
          let profundidade = nivel === 7 ? 2 : nivel === 8 ? 3 : nivel === 9 ? 4 : 5;
          let resultado = minimax(tabuleiro, profundidade, 2, -Infinity, Infinity);
          movimentoEscolhido = resultado.movimento;
          
          // Fallback: se minimax não retornou movimento válido, escolhe aleatoriamente
          if (!movimentoEscolhido && movimentos.length > 0) {
            console.log('Minimax falhou, usando movimento aleatório');
            let capturas = movimentos.filter(m => m.para.capturadaI !== undefined);
            movimentoEscolhido = capturas.length > 0 
              ? capturas[Math.floor(Math.random() * capturas.length)]
              : movimentos[Math.floor(Math.random() * movimentos.length)];
          }
        }
        if (!movimentoEscolhido) {
          console.log('Nenhum movimento disponível para a IA');
          turnoDaIA = false;
          document.getElementById("tabuleiro").style.pointerEvents = "auto";
          verificarVitoria();
          return;
        }
        let { de, para } = movimentoEscolhido;
        pecaSelecionada = de;
        destacarSelecionada(de.i, de.j);
        mostrarMovimentosPossiveis(de.i, de.j);
        setTimeout(() => {
          moverPeca(para.i, para.j, para, true);
        }, 500);
      }, 1000);
    }

    // Verifica se há um vencedor com base nas peças ou movimentos disponíveis
    function verificarVitoria() {
      let pecasJogador1 = 0, pecasJogador2 = 0;
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (tabuleiro[i][j]) {
            if (tabuleiro[i][j].jogador === 1) pecasJogador1++;
            else pecasJogador2++;
          }
        }
      }
      let movimentosJogador1 = obterTodosMovimentosPossiveis(1);
      let movimentosJogador2 = obterTodosMovimentosPossiveis(2);
      if (pecasJogador1 === 0 || movimentosJogador1.length === 0) {
        // IA vence
        tocarSom("som-vitoria");
        mostrarConfetes();
        setTimeout(mostrarConfetes, 900);
        setTimeout(mostrarConfetes, 1800);
        setTimeout(() => {
          mostrarModalVitoria({ vencedor: 'IA' });
          mostrarAnuncioIntersticial(); // Mostra anúncio quando IA vence
        }, 2500);
        return true;
      }
      if (pecasJogador2 === 0 || movimentosJogador2.length === 0) {
        // Você vence
        tocarSom("som-vitoria");
        if (modo === "Contra a Máquina") desbloquearProximoNivel();
        mostrarConfetes();
        setTimeout(mostrarConfetes, 900);
        setTimeout(mostrarConfetes, 1800);
        setTimeout(() => {
          mostrarModalVitoria({ vencedor: 'Você' });
          mostrarAnuncioIntersticial(); // Mostra anúncio quando jogador vence
        }, 2500);
        return true;
      }
      
      return false;
    }

    function mostrarModalVitoria({ vencedor }) {
      const overlay = document.getElementById('modal-overlay');
      const title = document.getElementById('modal-title');
      const msg = document.getElementById('modal-message');
      const btns = document.getElementById('modal-buttons');
      if (!overlay || !title || !msg || !btns) return;
      title.textContent = 'Fim de Jogo';
      // Define mensagem e botões conforme regras
      const nivelAtual = parseInt(document.getElementById('nivelDificuldade').value);
      btns.innerHTML = '';
      if (vencedor === 'Você' && modo === 'Contra a Máquina' && nivelAtual < 10) {
        msg.textContent = 'Você vence! Deseja ir para o próximo nível?';
        const sim = document.createElement('button');
        sim.textContent = 'Sim';
        sim.onclick = () => {
          try {
            const prox = Math.min(10, nivelAtual + 1);
            document.getElementById('nivelDificuldade').value = String(prox);
            salvarPreferenciasUI();
          } catch(e) {}
          overlay.style.display = 'none';
          iniciarJogo();
        };
        const nao = document.createElement('button');
        nao.textContent = 'Não';
        nao.onclick = () => { overlay.style.display = 'none'; };
        btns.appendChild(nao);
        btns.appendChild(sim);
      } else {
        // IA venceu ou já no nível 10
        msg.textContent = `${vencedor} vence! Deseja reiniciar o jogo?`;
        const nao = document.createElement('button');
        nao.textContent = 'Não';
        nao.onclick = () => { overlay.style.display = 'none'; };
        const sim = document.createElement('button');
        sim.textContent = 'Sim';
        sim.onclick = () => { overlay.style.display = 'none'; reiniciarJogo(); };
        btns.appendChild(nao);
        btns.appendChild(sim);
      }
      overlay.style.display = 'flex';
    }

    // Destaca os movimentos possíveis no tabuleiro
    function mostrarMovimentosPossiveis(i = null, j = null, i0 = null, j0 = null) {
      document.querySelectorAll(".casa.possivel").forEach(c => c.classList.remove("possivel"));
      if (i !== null && j !== null && tabuleiro[i][j]) {
        let movimentos = obterTodosMovimentos(i, j, i0, j0);
        for (let movimento of movimentos) {
          let casa = document.querySelector(`.casa[data-linha="${movimento.i}"][data-coluna="${movimento.j}"]`);
          if (casa) casa.classList.add("possivel");
        }
      }
    }

    // Inicializa o jogo com as configurações selecionadas
    function iniciarJogo() {
      corPecas[1] = cores[document.getElementById("corJ1").value];
      corPecas[2] = cores[document.getElementById("corJ2").value];
      corCasas = temaCores[document.getElementById("temaTabuleiro").value];
      modo = document.getElementById("modoJogo").value;
      nivel = parseInt(document.getElementById("nivelDificuldade").value);
      salvarPreferenciasUI();
      const musica = document.getElementById("musica-fundo");
      if (musica) {
        const vol = obterVolume();
        const muteMusica = obterMuteMusica();
        musica.volume = vol;
        if (!muteMusica && vol > 0) {
          musica.play().catch(() => {});
        } else {
          musica.pause();
        }
      }
      // Cria o tabuleiro e distribui as peças
      criarTabuleiro();
      turnoJogador = 1;
      capturaObrigatoria = temCapturasPossiveis(1);
      turnoDaIA = false;
      pecaSelecionada = null;
      const turnoElement = document.getElementById("turno");
      turnoElement.textContent = "Turno: Jogador " + turnoJogador;
      turnoElement.style.color = corPecas[turnoJogador];
      
      // Mostra a área de anúncios quando o jogo inicia
      const anunciosElement = document.getElementById("Anuncios");
      if (anunciosElement) {
        anunciosElement.style.display = "block";
      }
      
      atualizarVisual();
      if (modo === "Contra a Máquina" && turnoJogador === 2) {
        jogadaDaIA();
      }
      const menuEl = document.getElementById("menu");
      if (menuEl) menuEl.style.display = "none";
      const boardEl = document.getElementById("tabuleiro");
      const turnoEl = document.getElementById("turno");
      if (boardEl) boardEl.style.display = "grid";
      if (turnoEl) turnoEl.style.display = "block";
    }

    // Persistência de preferências de UI por usuário
    function salvarPreferenciasUI() {
      try {
        const prefs = {
          corJ1: document.getElementById("corJ1").value,
          corJ2: document.getElementById("corJ2").value,
          temaTabuleiro: document.getElementById("temaTabuleiro").value,
          modoJogo: document.getElementById("modoJogo").value,
          nivelDificuldade: document.getElementById("nivelDificuldade").value
        };
        localStorage.setItem('prefs_global', JSON.stringify(prefs));
      } catch (e) {}
    }

    function restaurarPreferenciasUI() {
      try {
        const salvo = localStorage.getItem('prefs_global');
        if (!salvo) return;
        const prefs = JSON.parse(salvo);
        if (prefs.corJ1) document.getElementById("corJ1").value = prefs.corJ1;
        if (prefs.corJ2) document.getElementById("corJ2").value = prefs.corJ2;
        if (prefs.temaTabuleiro) document.getElementById("temaTabuleiro").value = prefs.temaTabuleiro;
        if (prefs.modoJogo) document.getElementById("modoJogo").value = prefs.modoJogo;
        if (prefs.nivelDificuldade) document.getElementById("nivelDificuldade").value = prefs.nivelDificuldade;
        atualizarNiveisDesbloqueados();
      } catch (e) {}
    }

    // Cria o tabuleiro inicial com peças posicionadas
function animarDistribuicaoPecas() {
  document.querySelectorAll(".casa").forEach(c => c.innerHTML = "");
  tocarSom("som-distribuicao");
  let posicoes = [];
  for (let i = 0; i < 8; i++) {
    for (let j = 0; j < 8; j++) {
      if (tabuleiro[i][j]) posicoes.push({i, j, jogador: tabuleiro[i][j].jogador, dama: tabuleiro[i][j].dama});
    }
  }
  // Ponto de origem: canto superior esquerdo do tabuleiro
  const tabuleiroDiv = document.getElementById("tabuleiro");
  const origem = tabuleiroDiv.getBoundingClientRect();
  let idx = 0;
  function colocarProxima() {
   //hhhhhhhhhhhhhhhhhhhhhhhhh--------hhhhhhhhhhhhhhhhhhh 
    if (idx >= posicoes.length) return;
    let {i, j, jogador, dama} = posicoes[idx];
    const casa = document.querySelectorAll(".casa")[i * 8 + j];
    const destino = casa.getBoundingClientRect();
    
    // Calcula o deslocamento do ponto de origem até a casa destino
    const deltaX = destino.left - origem.left;
    const deltaY = destino.top - origem.top;
    
    // Cria a peça na posição de origem
    const peca = document.createElement("div");
    peca.classList.add("peca", "animando");
    if (dama) peca.classList.add("dama");
    peca.style.backgroundColor = corPecas[jogador];
    peca.style.position = "absolute";
    peca.style.left = "0px";
    peca.style.top = "0px";
    // Ajusta escala inicial baseada no tamanho da tela
    const isMobile = window.innerWidth <= 768;
    const escalaInicial = isMobile ? 0.1 : 0.2;
    peca.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(${escalaInicial})`;
    casa.appendChild(peca);

    // Força reflow para garantir a transição
    void peca.offsetWidth;
    // Move para o centro da casa (escala normal)
    peca.style.transition = "transform 0.5s cubic-bezier(.4,2,.6,1)";
    peca.style.transform = "translate(0,0) scale(1)";


    // Remove a classe de animação após a transição
    peca.addEventListener('transitionend', () => {
      peca.classList.remove("animando");
      peca.style.position = "";
      peca.style.left = "";
      peca.style.top = "";
      peca.style.transition = "";
      peca.style.transform = "";
      peca.style.pointerEvents = "";
    }, { once: true });

    idx++;
    setTimeout(colocarProxima, 100); // velocidade do efeito (ms)
  }
  colocarProxima();
}

//  criarTabuleiro para não criar as peças imediatamente:
function criarTabuleiro() {
  tabuleiro = [];
  const tab = document.getElementById("tabuleiro");
  tab.innerHTML = "";
  for (let i = 0; i < 8; i++) {
    tabuleiro[i] = [];
    for (let j = 0; j < 8; j++) {
      const casa = document.createElement("div");
      casa.classList.add("casa");
      if ((i + j) % 2 === 0) {
        casa.classList.add("clara");
        casa.style.backgroundColor = corCasas[1];
        tabuleiro[i][j] = null;
      } else {
        casa.classList.add("escura");
        casa.style.backgroundColor = corCasas[0];
        if (i < 3) {
          tabuleiro[i][j] = { jogador: 2, dama: false };
        } else if (i > 4) {
          tabuleiro[i][j] = { jogador: 1, dama: false };
        } else {
          tabuleiro[i][j] = null;
        }
      }
      casa.dataset.linha = i;
      casa.dataset.coluna = j;
      casa.onclick = () => selecionarCasa(i, j);
      tab.appendChild(casa);
    }
  }
  // Chama a animação após montar o tabuleiro
  setTimeout(animarDistribuicaoPecas, 100);
}

    // Gerencia a seleção de casas pelo jogador humano
    function selecionarCasa(i, j) {
      if (turnoDaIA || (modo === "Contra a Máquina" && turnoJogador === 2)) return;
      if (pecaSelecionada) {
        let {i: i0, j: j0, i0: iPrev, j0: jPrev} = pecaSelecionada;
        // Se há posição anterior (captura múltipla), passa para bloquear direção oposta
        let movimentos = obterTodosMovimentos(i0, j0, iPrev, jPrev);
        let movimentoValido = movimentos.find(m => m.i == i && m.j == j);
        if (movimentoValido) {
          moverPeca(i, j, movimentoValido, false);
        } else {
          // Se está em captura múltipla (iPrev definido), NÃO permite desselecionar
          // A peça DEVE continuar capturando se houver capturas disponíveis
          if (iPrev !== undefined && jPrev !== undefined) {
            let capturasObrigatorias = obterCapturasPossiveis(i0, j0, iPrev, jPrev);
            if (capturasObrigatorias.length > 0) {
              // Tem capturas obrigatórias, não pode desselecionar
              // Apenas destaca novamente a peça
              destacarSelecionada(i0, j0);
              return;
            }
          }
          
          // Permite desselecionar apenas se não houver capturas múltiplas pendentes
          pecaSelecionada = null;
          document.querySelectorAll(".casa").forEach(c => c.classList.remove("selecionada"));
          mostrarMovimentosPossiveis();
        }
      } else {
        if (tabuleiro[i][j] && tabuleiro[i][j].jogador === turnoJogador) {
          if (modo === "Contra a Máquina" && tabuleiro[i][j].jogador === 2) return;
          let movimentos = obterTodosMovimentos(i, j);
          if (movimentos.length > 0) {
            pecaSelecionada = {i, j};
            destacarSelecionada(i, j);
            mostrarMovimentosPossiveis(i, j);
          }
        }
      }
    }

    // Destaca a casa da peça selecionada
    function destacarSelecionada(i, j) {
      document.querySelectorAll(".casa").forEach(c => c.classList.remove("selecionada"));
      const idx = i * 8 + j;
      document.querySelectorAll(".casa")[idx].classList.add("selecionada");
    }

    // Move uma peça e gerencia capturas múltiplas, coroando apenas no final da jogada
    function moverPeca(i, j, movimento, ehIA = false) {
      tocarSom("som-movimento");
      let {i: i0, j: j0} = pecaSelecionada;
      let peca = tabuleiro[i0][j0];
      tabuleiro[i][j] = peca;
      tabuleiro[i0][j0] = null;
      let maisCapturas = false;
      if (movimento.capturadaI !== undefined && movimento.capturadaJ !== undefined) {
        tabuleiro[movimento.capturadaI][movimento.capturadaJ] = null;
        // Passa a posição anterior (i0, j0) para bloquear direção oposta em capturas múltiplas
        maisCapturas = obterCapturasPossiveis(i, j, i0, j0).length > 0;
      }
      // Coroação só ocorre se não houver capturas adicionais e a peça estiver na última linha
      if (!maisCapturas && ((peca.jogador === 1 && i === 0) || (peca.jogador === 2 && i === 7))) {
        peca.dama = true;
      }
      atualizarVisual();
      //-------------------------------------------------------------------
      if (maisCapturas) {
        // Permanece na mesma peça para a próxima captura
        pecaSelecionada = {i, j, i0, j0}; // Armazena também a posição anterior
        mostrarMovimentosPossiveis(i, j, i0, j0);
        destacarSelecionada(i, j);

        // Caso seja a IA, repetir a jogada automaticamente até não haver mais capturas
        if (ehIA) {
          setTimeout(() => {
            // Passa posição anterior para bloquear direção oposta
            let capturas = obterCapturasPossiveis(i, j, i0, j0);
            if (capturas.length > 0) {
              // Continua a jogada da IA com a mesma peça
              let proximaCaptura = capturas[Math.floor(Math.random() * capturas.length)];
              moverPeca(proximaCaptura.i, proximaCaptura.j, proximaCaptura, true);
            } else {
              // Finaliza a jogada e troca o turno
              pecaSelecionada = null;
              document.querySelectorAll(".casa").forEach(c => c.classList.remove("selecionada"));
              mostrarMovimentosPossiveis();
              turnoDaIA = false;
              document.getElementById("tabuleiro").style.pointerEvents = "auto";
              trocarTurno();
            }
          }, 800);
          return;
        }

        return; // Jogador humano segue com nova captura
      }

      //-------------------------------------------------------------------
      pecaSelecionada = null;
      document.querySelectorAll(".casa").forEach(c => c.classList.remove("selecionada"));
      mostrarMovimentosPossiveis();
      turnoDaIA = false;
      document.getElementById("tabuleiro").style.pointerEvents = "auto";
      trocarTurno();
    }

    // Atualiza a visualização do tabuleiro com base no estado atual
    function atualizarVisual() {
      document.querySelectorAll(".casa").forEach(c => c.innerHTML = "");
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const casa = document.querySelectorAll(".casa")[i * 8 + j];
          const conteudo = tabuleiro[i][j];
          if (conteudo) {
            const peca = document.createElement("div");
            peca.classList.add("peca");
            if (conteudo.dama) peca.classList.add("dama");
            peca.style.backgroundColor = corPecas[conteudo.jogador];
            casa.appendChild(peca);
          }
        }
      }
    }

    // Troca o turno do jogador e verifica condições de vitória
    function trocarTurno() {
      turnoJogador = turnoJogador === 1 ? 2 : 1;
      capturaObrigatoria = temCapturasPossiveis(turnoJogador);
      const turnoElement = document.getElementById("turno");
      turnoElement.textContent = "Turno: Jogador " + turnoJogador;
      turnoElement.style.color = corPecas[turnoJogador];
      atualizarVisual();
      if (verificarVitoria()) return;
      if (modo === "Contra a Máquina" && turnoJogador === 2) {
        setTimeout(jogadaDaIA, 1000);
      }
    }

    // Reinicia o jogo com as configurações atuais
    function reiniciarJogo() {
      turnoDaIA = false;
      document.getElementById("tabuleiro").style.pointerEvents = "auto";
      const boardEl = document.getElementById("tabuleiro");
      const turnoEl = document.getElementById("turno");
      if (boardEl) boardEl.style.display = "grid";
      if (turnoEl) turnoEl.style.display = "block";
      iniciarJogo();
    }

    // Alterna a visibilidade do menu na tela principal
    function alternarMenu() {
      const menu = document.getElementById('menu');
      const visivel = menu.style.display === 'block';
      const novoVisivel = !visivel;
      menu.style.display = novoVisivel ? 'block' : 'none';
      const board = document.getElementById('tabuleiro');
      const turno = document.getElementById('turno');
      const musica = document.getElementById('musica-fundo');
      
      if (novoVisivel) {
        // Oculta o tabuleiro e o indicador de turno quando o menu está aberto
        if (board) board.style.display = 'none';
        if (turno) turno.style.display = 'none';
        // Mantém estado de música conforme preferências
      } else {
        // Reexibe quando o menu é fechado
        if (board) board.style.display = 'grid';
        if (turno) turno.style.display = 'block';
        if (musica) {
          const vol = obterVolume();
          const muteMusica = obterMuteMusica();
          musica.volume = vol;
          if (!muteMusica && vol > 0) musica.play().catch(() => {});
        }
      }
    }

    // Função para sair do jogo
    function sairDoAplicativo() {
      try {
        if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone) {
          window.close();
        }
      } catch(e) {}
      // Fallback: volta para a tela de opções
      const menu = document.getElementById('menu');
      const board = document.getElementById('tabuleiro');
      const turno = document.getElementById('turno');
      if (menu) menu.style.display = 'block';
      if (board) board.style.display = 'none';
      if (turno) turno.style.display = 'none';
      
      // Oculta a área de anúncios quando abre o menu
      const anunciosElement = document.getElementById("Anuncios");
      if (anunciosElement) {
        anunciosElement.style.display = "none";
      }
    }

    // Voltar ao Jogo: fecha menu e retorna ao tabuleiro mantendo estado
    function voltarAoJogo() {
      const menu = document.getElementById('menu');
      const board = document.getElementById('tabuleiro');
      const turno = document.getElementById('turno');
      if (menu) menu.style.display = 'none';
      if (board) board.style.display = 'grid';
      if (turno) turno.style.display = 'block';
      
      // Mostra a área de anúncios quando volta ao jogo
      const anunciosElement = document.getElementById("Anuncios");
      if (anunciosElement) {
        anunciosElement.style.display = "block";
      }
    }

    // Mostra anúncio intersticial entre jogadas
    function mostrarAnuncioIntersticial() {
      try {
        // 30% de chance de mostrar anúncio
        if (Math.random() < 0.3) {
          const anuncioIntersticial = document.getElementById('anuncioIntersticial');
          if (anuncioIntersticial) {
            anuncioIntersticial.style.display = 'block';
            (adsbygoogle = window.adsbygoogle || []).push({});
            // Oculta após 5 segundos
            setTimeout(() => {
              anuncioIntersticial.style.display = 'none';
            }, 5000);
          }
        }
      } catch (e) {
        console.error('Erro ao mostrar anúncio intersticial:', e);
      }
    }

    // Toca um som específico ao clicar em botões
    function tocarSom(id) {
      const efeitosMutados = obterMuteEfeitos();
      if (efeitosMutados && id !== 'musica-fundo') return;
      const audio = document.getElementById(id);
      if (audio) {
        const vol = obterVolume();
        audio.volume = vol;
        audio.currentTime = 0;
        const playPromise = audio.play();
        if (playPromise && typeof playPromise.catch === 'function') {
          playPromise.catch(() => {});
        }
      }
    }
    // Exibe confetes na tela após uma vitória  
    function mostrarConfetes() {
    const container = document.getElementById("confete-container");
    container.innerHTML = "";
    container.style.display = "block";
    const cores = ["#ff0", "#f00", "#0f0", "#00f", "#ff69b4", "#ffa500"];
    for (let i = 0; i < 80; i++) {
      const confete = document.createElement("div");
      confete.style.position = "absolute";
      confete.style.width = "12px";
      confete.style.height = "12px";
      confete.style.borderRadius = "50%";
      confete.style.background = cores[Math.floor(Math.random() * cores.length)];
      confete.style.left = Math.random() * window.innerWidth + "px";
      confete.style.top = "-20px";
      confete.style.opacity = "0.8";
      confete.style.transition = "top 2s cubic-bezier(.4,2,.6,1), left 2s";
      container.appendChild(confete);
      setTimeout(() => {
        confete.style.top = (window.innerHeight - 40) + "px";
        confete.style.left = (parseFloat(confete.style.left) + (Math.random() * 100 - 50)) + "px";
      }, 50);
    }
    // Remove confetes após 2.8 segundos
    setTimeout(() => {
      container.style.display = "none";
      container.innerHTML = "";
    }, 2800);
  }


    // ======= Inicialização sem login =======
    (function initSemLogin(){
      // Mostrar opções imediatamente
      document.getElementById('menu').style.display = 'block';
      // Restaurar preferências
      restaurarPreferenciasUI();
      atualizarNiveisDesbloqueados();
      // Configurar volume UI
      configurarControlesDeAudio();
      // Construir prévia inicial
      construirPreview();
      atualizarPreview();
      // Atualiza prévia ao mudar seletores
      ['corJ1','corJ2','temaTabuleiro'].forEach(id => {
        const el = document.getElementById(id);
        el.addEventListener('change', () => { salvarPreferenciasUI(); atualizarPreview(); });
      });
    })();

    // ======= Áudio: preferências =======
    function obterVolume(){
      try { return Math.max(0, Math.min(1, parseFloat(localStorage.getItem('volume_geral') || '1'))); } catch(e){ return 1; }
    }
    function salvarVolume(v){
      try { localStorage.setItem('volume_geral', String(v)); } catch(e){}
    }
    function obterMuteMusica(){
      try { return localStorage.getItem('mute_musica') === '1'; } catch(e){ return false; }
    }
    function salvarMuteMusica(flag){
      try { localStorage.setItem('mute_musica', flag ? '1' : '0'); } catch(e){}
    }
    function obterMuteEfeitos(){
      try { return localStorage.getItem('mute_efeitos') === '1'; } catch(e){ return false; }
    }
    function salvarMuteEfeitos(flag){
      try { localStorage.setItem('mute_efeitos', flag ? '1' : '0'); } catch(e){}
    }
    function configurarControlesDeAudio(){
      const label = document.getElementById('label-volume');
      const btnMenos = document.getElementById('btn-vol-menor');
      const btnMais = document.getElementById('btn-vol-maior');
      const chkMusica = document.getElementById('mute-musica');
      const chkEfeitos = document.getElementById('mute-efeitos');
      const musica = document.getElementById('musica-fundo');
      let vol = obterVolume();
      label.textContent = Math.round(vol*100) + '%';
      chkMusica.checked = obterMuteMusica();
      chkEfeitos.checked = obterMuteEfeitos();
      function aplicar(){
        salvarVolume(vol);
        if (musica){
          musica.volume = vol;
          if (!chkMusica.checked && vol > 0) {
            musica.play().catch(()=>{});
          } else {
            musica.pause();
          }
        }
      }
      btnMenos.onclick = () => { vol = Math.max(0, +(vol - 0.1).toFixed(2)); label.textContent = Math.round(vol*100)+'%'; aplicar(); };
      btnMais.onclick = () => { vol = Math.min(1, +(vol + 0.1).toFixed(2)); label.textContent = Math.round(vol*100)+'%'; aplicar(); };
      chkMusica.onchange = () => { salvarMuteMusica(chkMusica.checked); aplicar(); };
      chkEfeitos.onchange = () => { salvarMuteEfeitos(chkEfeitos.checked); };
      aplicar();
    }

    // ======= Prévia do tabuleiro =======
    function construirPreview(){
      const prev = document.getElementById('preview');
      if (!prev) return;
      prev.innerHTML = '';
      for (let i=0;i<8;i++){
        for (let j=0;j<8;j++){
          const sq = document.createElement('div');
          sq.style.width = '14px';
          sq.style.height = '14px';
          sq.dataset.i = i; sq.dataset.j = j;
          prev.appendChild(sq);
        }
      }
    }
    function atualizarPreview(){
      const tema = document.getElementById('temaTabuleiro').value;
      const c1 = cores[document.getElementById('corJ1').value];
      const c2 = cores[document.getElementById('corJ2').value];
      const [escura, clara] = temaCores[tema];
      const prev = document.getElementById('preview');
      if (!prev) return;
      const children = prev.children;
      for (let i=0;i<8;i++){
        for (let j=0;j<8;j++){
          const idx = i*8+j;
          const el = children[idx];
          if ((i+j)%2===0){
            el.style.background = clara;
          } else {
            el.style.background = escura;
          }
          el.style.position = 'relative';
          el.innerHTML = '';
          if ((i<2 && (i+j)%2===1)){
            const p = document.createElement('div');
            p.style.width = '8px'; p.style.height='8px'; p.style.borderRadius='50%'; p.style.background=c2; p.style.margin='3px auto 0';
            el.appendChild(p);
          }
          if ((i>5 && (i+j)%2===1)){
            const p = document.createElement('div');
            p.style.width = '8px'; p.style.height='8px'; p.style.borderRadius='50%'; p.style.background=c1; p.style.margin='3px auto 0';
            el.appendChild(p);
          }
        }
      }
    }
  </script>
</body>
</html>